<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#
    // Configuration
    int minGenerics = 2;
    int maxGenerics = 16;
#>
using System.Collections;
using System.ComponentModel;

namespace TableStorage.Fluent;

#nullable disable
#pragma warning disable IDE2000

<# for (int genericCount = minGenerics; genericCount <= maxGenerics; genericCount++) { 
    GenerateClass("FluentTableEntity", "$type", true, genericCount);
    GenerateClass("FluentPartitionTableEntity", "PartitionKey", false, genericCount);
    GenerateClass("FluentRowTypeTableEntity", "RowKey", false, genericCount);
} #>

<#+
    private void GenerateClass(string className, string discriminator, bool isVirtualDiscriminator, int genericCount)
    {
        // Generate generic type parameters
        var typeParams = Enumerable.Range(1, genericCount)
            .Select(i => $"T{i}")
            .ToList();
        
        var typeParamList = string.Join(", ", typeParams);
        
        // Generate constraints
        var constraints = typeParams
            .Select(t => $"where {t} : class, IDictionary<string, object>, ITableEntity, new()")
            .ToList();
        
        var constraintList = string.Join("\n    ", constraints);
        
        // Generate implicit operators for all types
        var operators = new List<string>();
        for (int i = 0; i < genericCount; i++)
        {
            var typeName = typeParams[i];
            var backingTypeValue = (i + 1 <= 16) ? $"FluentBackingType.{GetOrdinalName(i + 1)}" : "FluentBackingType.NotInitialized";
            
            operators.Add($@"    public {className}(T{i + 1} entity)
    {{
        _backingType = {backingTypeValue};
        _backingDictionary = entity;
    }}

    public static implicit operator {className}<{typeParamList}>(T{i + 1} entity) => new(entity);
    public static implicit operator T{i + 1}({className}<{typeParamList}> entity) => (T{i + 1})entity._backingDictionary;
");
        }
        
        var operatorList = string.Join("\n", operators);
        
        // Generate switch cases for GetActualType
        var switchCases = new List<string>();
        for (int i = 0; i < genericCount; i++)
        {
            var backingTypeValue = $"FluentBackingType.{GetOrdinalName(i + 1)}";
            switchCases.Add($"        {backingTypeValue} => typeof(T{i + 1}),");
        }
        
        var actualTypeSwitchCases = string.Join("\n", switchCases);
        
        // Generate switch cases for SwitchCase
        var switchCaseMethods = new List<string>();
        for (int i = 0; i < genericCount; i++)
        {
            var backingTypeValue = $"FluentBackingType.{GetOrdinalName(i + 1)}";
            switchCaseMethods.Add($"        {backingTypeValue} when case{i + 1} is not null => case{i + 1}(this),");
        }
        
        var switchCaseParams = string.Join(", ", typeParams.Select((t, i) => $"Func<T{i + 1}, T> case{i + 1} = null"));
        var switchCaseCases = string.Join("\n", switchCaseMethods);
        
        // Generate switch cases for SwitchCaseOrDefault
        var switchCaseDefaultParams = string.Join(", ", typeParams.Select((t, i) => $"Func<T{i + 1}, T> case{i + 1} = null"));
        var switchCaseDefaultCases = string.Join("\n", switchCaseMethods);
        
        // Generate discriminator type cases
        var discriminatorCases = new List<string>();
        for (int i = 0; i < genericCount; i++)
        {
            var backingTypeValue = $"FluentBackingType.{GetOrdinalName(i + 1)}";
            discriminatorCases.Add($"            {backingTypeValue} => typeof(T{i + 1}).Name,");
        }
        
        var discriminatorCaseList = string.Join("\n", discriminatorCases);
        
        // Generate type discriminator assignment cases
        var typeDiscriminatorCases = new List<string>();
        for (int i = 1; i < genericCount; i++)
        {
            typeDiscriminatorCases.Add($"else if (type == typeof(T{i + 1}).Name)\n                {{\n                    _backingType = FluentBackingType.{GetOrdinalName(i + 1)};\n                    Create<T{i + 1}>();\n                }}");
        }
        
        var typeDiscriminatorList = string.Join("\n                ", typeDiscriminatorCases);
#>
public sealed class <#= className #><<#= typeParamList #>> : IDictionary<string, object>, ITableEntity
    <#= constraintList #>
{
    private const string Discriminator = "<#= discriminator #>";

    [EditorBrowsable(EditorBrowsableState.Never)]
    public static TableSet<<#= className #><<#= typeParamList #>>> CreateTableSet(ICreator creator, string name)
        => creator.CreateSet<<#= className #><<#= typeParamList #>>>(name, null, null);

    private FluentBackingType _backingType;
    private IDictionary<string, object> _backingDictionary;

    /// <summary>
    /// This should only be used by the Table SDK when deserializing entities.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public <#= className #>()
    {
        _backingType = FluentBackingType.NotInitialized;
        _backingDictionary = new Dictionary<string, object>();
    }

<#= operatorList #>
    public FluentBackingType GetBackingType() => _backingType;

    public Type GetActualType() => _backingType switch
    {
<#= actualTypeSwitchCases #>
        _ => null
    };

    public object GetValue() => _backingType switch
    {
        FluentBackingType.NotInitialized => throw new InvalidOperationException(),
        _ => _backingDictionary
    };

    public object GetValueOrDefault() => _backingType switch
    {
        FluentBackingType.NotInitialized => null,
        _ => _backingDictionary
    };

    public T SwitchCase<T>(<#= switchCaseParams #>) => _backingType switch
    {
<#= switchCaseCases #>
        _ => throw new InvalidOperationException()
    };

    public T SwitchCaseOrDefault<T>(<#= switchCaseDefaultParams #>, Func<T> defaultCase = null) => _backingType switch
    {
<#= switchCaseDefaultCases #>
        _ when defaultCase is not null => defaultCase(),
        _ => default
    };

    public string PartitionKey
    {
<#+ if (discriminator == "PartitionKey") { #>
        get => GetDiscriminatorType();
        set => this[Discriminator] = value;
<#+ } else { #>
        get
        {
            if (_backingDictionary.TryGetValue("PartitionKey", out object result))
            {
                return result?.ToString();
            }

            return null;
        }

        set => _backingDictionary["PartitionKey"] = value;
<#+ } #>
    }

    public string RowKey
    {
<#+ if (discriminator == "RowKey") { #>
        get => GetDiscriminatorType();
        set => this[Discriminator] = value;
<#+ } else { #>
        get
        {
            if (_backingDictionary.TryGetValue("RowKey", out object result))
            {
                return result?.ToString();
            }

            return null;
        }
        set => _backingDictionary["RowKey"] = value;
<#+ } #>
    }

    public DateTimeOffset? Timestamp
    {
        get
        {
            if (_backingDictionary.TryGetValue("Timestamp", out object result) && result is DateTimeOffset dateTimeOffset)
            {
                return dateTimeOffset;
            }

            return null;
        }
        set => _backingDictionary["Timestamp"] = value;
    }

    public ETag ETag
    {
        get
        {
            if (_backingDictionary.TryGetValue("odata.etag", out object result))
            {
                if (result is ETag eTag)
                {
                    return eTag;
                }

                if (result?.ToString() is string eTagString)
                {
                    return new(eTagString);
                }
            }

            return default;
        }

        set => _backingDictionary["odata.etag"] = value;
    }

    public object this[string key]
    {
        get
        {
            if (key is Discriminator)
            {
                return GetDiscriminatorType();
            }

            if (_backingDictionary.TryGetValue(key, out object result))
            {
                return result;
            }

            return null;
        }

        set
        {
            if (key is Discriminator)
            {
                string type = value?.ToString();

                if (type == typeof(T1).Name)
                {
                    _backingType = FluentBackingType.First;
                    Create<T1>();
                }
                <#= typeDiscriminatorList #>
                else
                {
                    throw new InvalidOperationException($"Invalid type specified: {value}");
                }

<#+ if (!isVirtualDiscriminator) { #>
                _backingDictionary[key] = value;

<#+ } #>
                void Create<T>() where T : class, IDictionary<string, object>, ITableEntity, new()
                {
                    IDictionary<string, object> original = _backingDictionary;
                    _backingDictionary = new T();

                    foreach (KeyValuePair<string, object> kvp in original)
                    {
                        _backingDictionary[kvp.Key] = kvp.Value;
                    }
                }
            }
            else
            {
                _backingDictionary[key] = value;
            }
        }
    }

    private string GetDiscriminatorType()
    {
        return _backingType switch
        {
<#= discriminatorCaseList #>
            _ => null
        };
    }

<#+ if (isVirtualDiscriminator) { #>
    public ICollection<string> Keys => new KeyCollectionHelper(_backingDictionary, Discriminator);
    public ICollection<object> Values => new ValueCollectionHelper(_backingDictionary, GetDiscriminatorType());

    public int Count => _backingDictionary.Count + 1;
    public bool IsReadOnly => false;

    public void Add(string key, object value) => _backingDictionary.Add(key, value);
    public bool ContainsKey(string key) => key == Discriminator || _backingDictionary.ContainsKey(key);
    public bool Remove(string key) => _backingDictionary.Remove(key);

    public bool TryGetValue(string key, out object value)
    {
        if (key == Discriminator)
        {
            value = GetDiscriminatorType();
            return true;
        }

        return _backingDictionary.TryGetValue(key, out value);
    }

    public void Add(KeyValuePair<string, object> item) => _backingDictionary.Add(item);
    public void Clear() => _backingDictionary.Clear();

    public bool Contains(KeyValuePair<string, object> item)
    {
        if (item.Key == Discriminator)
        {
            return Equals(item.Value, GetDiscriminatorType());
        }

        return _backingDictionary.Contains(item);
    }

    public void CopyTo(KeyValuePair<string, object>[] array, int arrayIndex)
    {
        if (array is null)
        {
            throw new ArgumentNullException(nameof(array));
        }

        if (arrayIndex < 0 || arrayIndex > array.Length)
        {
            throw new ArgumentOutOfRangeException(nameof(arrayIndex));
        }

        if (array.Length - arrayIndex < Count)
        {
            throw new ArgumentException("The number of elements in the source collection is greater than the available space from arrayIndex to the end of the destination array.");
        }

        array[arrayIndex++] = new(Discriminator, GetDiscriminatorType());
        _backingDictionary.CopyTo(array, arrayIndex);
    }

    public bool Remove(KeyValuePair<string, object> item) => _backingDictionary.Remove(item);
    public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
    {
        yield return new(Discriminator, GetDiscriminatorType());
        foreach (var kvp in _backingDictionary)
        {
            yield return kvp;
        }
    }
<#+ } else { #>
    public ICollection<string> Keys => _backingDictionary.Keys;
    public ICollection<object> Values => _backingDictionary.Values;

    public int Count => _backingDictionary.Count;
    public bool IsReadOnly => false;

    public void Add(string key, object value) => _backingDictionary.Add(key, value);
    public bool ContainsKey(string key) => _backingDictionary.ContainsKey(key);
    public bool Remove(string key) => _backingDictionary.Remove(key);

    public bool TryGetValue(string key, out object value)
    {
        if (key == Discriminator)
        {
            value = GetDiscriminatorType();
            return true;
        }

        return _backingDictionary.TryGetValue(key, out value);
    }

    public void Add(KeyValuePair<string, object> item) => _backingDictionary.Add(item);
    public void Clear() => _backingDictionary.Clear();

    public bool Contains(KeyValuePair<string, object> item) => _backingDictionary.Contains(item);

    public void CopyTo(KeyValuePair<string, object>[] array, int arrayIndex) => _backingDictionary.CopyTo(array, arrayIndex);

    public bool Remove(KeyValuePair<string, object> item) => _backingDictionary.Remove(item);
    public IEnumerator<KeyValuePair<string, object>> GetEnumerator() => _backingDictionary.GetEnumerator();
<#+ } #>

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}<#+
    }

    private string GetOrdinalName(int number)
    {
        return number switch
        {
            1 => "First",
            2 => "Second",
            3 => "Third",
            4 => "Fourth",
            5 => "Fifth",
            6 => "Sixth",
            7 => "Seventh",
            8 => "Eight",
            9 => "Ninth",
            10 => "Tenth",
            11 => "Eleventh",
            12 => "Twelfth",
            13 => "Thirteenth",
            14 => "Fourteenth",
            15 => "Fifteenth",
            16 => "Sixteenth",
            _ => throw new ArgumentOutOfRangeException(nameof(number))
        };
    }
#>